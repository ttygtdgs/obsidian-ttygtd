# PDF → PPTX 変換プロトタイプ 技術説明書

scheme verge株式会社 | 博報堂メディカル様向け | 2026年2月

---

## 1. 概要

### 1.1 目的

医薬品の製品情報PDF（総合製品情報概要等）をPowerPoint形式（16:9）に自動変換するプロトタイプ。
変換後のテキストは**テキストデータとして保持**され、PowerPoint上で直接編集可能な状態で出力される。

### 1.2 プロトタイプの実績

| 項目 | 値 |
|------|-----|
| 入力PDF | ピアスカイ製品情報概要 (v0.3) |
| ページ数 | 67ページ |
| 出力 | 67スライド（16:9） |
| ファイルサイズ | 1.2MB |
| 実行時間 | 数秒 |

### 1.3 変換で保持される情報

- テキスト内容（編集可能なテキストボックスとして配置）
- フォントサイズ・色・太字・斜体
- テキストの位置座標
- セクションヘッダーやテーブルヘッダーの背景色
- 埋め込み画像（ロゴ、グラフ等）

---

## 2. 技術スタック

| ライブラリ | バージョン | 役割 |
|-----------|----------|------|
| **PyMuPDF (fitz)** | 1.27.1 | PDF解析。テキスト・描画・画像の抽出 |
| **python-pptx** | 1.0.2 | PPTX生成。スライド・テキストボックス・図形・画像の配置 |
| **Pillow** | 12.1.0 | 画像処理の補助 |
| **Python** | 3.13.7 | 実行環境 |

外部サービスへの依存はなく、すべてローカルで完結する。

---

## 3. 全体アーキテクチャ

### 3.1 変換パイプライン

PDFの各ページを3つのレイヤーに分解し、スライド上に順序通り重ねて再構成する。

```
PDF (1ページ)
  │
  ├─ STEP 1: PDF読込
  │    PyMuPDF (fitz.open) でページを開く
  │
  ├─ STEP 2: 背景矩形の抽出・配置  ← Layer 1 (最背面)
  │    page.get_drawings() → add_shape(RECTANGLE)
  │
  ├─ STEP 3: 画像の抽出・配置      ← Layer 2 (中間)
  │    page.get_images() → add_picture()
  │
  ├─ STEP 4: テキストの抽出・配置   ← Layer 3 (最前面)
  │    page.get_text("dict") → add_textbox()
  │
  └─ 出力: PPTXスライド (16:9)
```

レイヤーの重ね順が重要で、背景→画像→テキストの順にスライドへ追加することで、テキストが常に最前面に表示される。

### 3.2 メイン処理フロー

```python
def convert_pdf_to_pptx(pdf_path, output_path):
    doc = fitz.open(pdf_path)
    prs = Presentation()  # 16:9で初期化

    for page in doc:
        slide = prs.slides.add_slide(blank_layout)

        # 1. 背景矩形
        add_background_shapes(slide, page.get_drawings(), ...)

        # 2. 画像
        extract_page_images_as_clip(page, slide, ...)

        # 3. テキスト
        blocks = page.get_text("dict")["blocks"]
        lines = merge_spans_into_lines(blocks)
        textboxes = group_lines_into_textboxes(lines)
        add_textboxes(slide, textboxes, ...)

    prs.save(output_path)
```

---

## 4. 座標変換

### 4.1 問題

PDFはA4縦（595 x 842 pt）、出力スライドは16:9横（960 x 540 pt）。
縦横比が異なるため、単純な1:1マッピングはできない。

### 4.2 解法：フィットスケーリング + センタリング

```
scale = min(slide_width / pdf_width, slide_height / pdf_height)
      = min(960 / 595, 540 / 842)
      = min(1.6134, 0.6413)
      = 0.6413

offset_x = (960 - 595 × 0.6413) / 2 = 289.2 pt
offset_y = (540 - 842 × 0.6413) / 2 = 0.0 pt
```

高さ方向でフィットするため、左右に約289ptの余白が生じる。

### 4.3 座標変換式

PDF上の座標 `(x, y)` をスライド上の座標に変換する：

```
slide_x = pdf_x × scale + offset_x
slide_y = pdf_y × scale + offset_y
slide_w = pdf_w × scale
slide_h = pdf_h × scale
```

最終的にPPTXのEMU単位（1pt = 12,700 EMU）に変換して配置する。

### 4.4 スライドサイズの定数

```python
SLIDE_WIDTH_EMU  = 12,192,000  # 960pt = 25.4cm
SLIDE_HEIGHT_EMU =  6,858,000  # 540pt = 14.288cm
PT_TO_EMU        =     12,700  # 1pt = 12,700 EMU
```

---

## 5. テキスト抽出

### 5.1 PyMuPDFのテキスト構造

`page.get_text("dict")` で取得されるテキストは、以下の3階層構造を持つ：

```
Block（テキストブロック）
  └── Line（行）
        └── Span（書式単位）
              ├── text:   テキスト文字列
              ├── font:   フォント名 (例: "YuGothic-Light")
              ├── size:   フォントサイズ (pt)
              ├── color:  文字色 (RGB整数値, 例: 0x003F72)
              ├── flags:  書式フラグ (ビットマスク)
              └── bbox:   位置座標 [x0, y0, x1, y1]
```

**flagsのビットマスク：**

| ビット | 値 | 意味 |
|--------|-----|------|
| bit 0 | 1 | superscript（上付き） |
| bit 1 | 2 | italic（斜体） |
| bit 2 | 4 | serif（セリフ体） |
| bit 3 | 8 | monospace（等幅） |
| bit 4 | 16 | bold（太字） |

### 5.2 テキストボックスのグルーピング

PDFのLine（行）はそのままではPPTX上で細かすぎるため、近接するLineをグループ化して1つのテキストボックスにまとめる。

**グルーピングのアルゴリズム：**

1. 全Lineを Y座標（上端）でソートする
2. 前のLineの下端と、現在のLineの上端の間隔（vertical_gap）を計算
3. 以下の**両方**を満たす場合、同一グループとする：
   - `vertical_gap < フォントサイズ × 1.5`
   - `左端のシフト量 < 200pt`
4. 条件を満たさない場合、新しいグループを開始する
5. 各グループの外接矩形を計算し、PPTXのTextBoxとして配置する

### 5.3 書式のマッピング

| PDF (PyMuPDF) | 変換処理 | PPTX (python-pptx) |
|---------------|---------|---------------------|
| `span["size"]` (例: 12.0pt) | × scale (0.6413) | `run.font.size = Pt(7.7)` |
| `span["color"]` (例: 0x003F72) | RGBビット分解 | `run.font.color.rgb = RGBColor(0, 63, 114)` |
| `span["flags"] & 16` | ビットマスク判定 | `run.font.bold = True` |
| `span["flags"] & 2` | ビットマスク判定 | `run.font.italic = True` |
| `span["font"]` (例: "YuGothic-Light") | 名称マッチング | `run.font.name = "游ゴシック"` |
| `span["bbox"]` [x0,y0,x1,y1] | 座標変換 + EMU換算 | `add_textbox(sx, sy, sw, sh)` |

### 5.4 フォント名マッピング

PDF内のフォント名を部分一致で判定し、PPTX用のフォント名に変換する：

| PDF内のフォント名（部分一致） | PPTX出力フォント |
|---------------------------|----------------|
| `Gothic` / `ゴシック` | 游ゴシック |
| `Mincho` / `明朝` | 游明朝 |
| `Arial` | Arial |
| その他 | 游ゴシック（デフォルト） |

### 5.5 スキップ条件

以下のテキストブロックは出力対象外とする：

- 全スパンが空白のみのブロック
- ページ番号のみのブロック（3桁以下の数字のみ）

---

## 6. 背景矩形の処理

### 6.1 抽出元

`page.get_drawings()` で取得される描画オブジェクト（矩形）。
PDF内のセクションヘッダーの色帯、テーブルヘッダーの背景色、ボックスの囲み等に該当する。

### 6.2 フィルタリング条件

PDFには大量の描画オブジェクトが含まれるが、すべてが背景として有用ではない。
以下の条件で不要なオブジェクトを除外する：

| 条件 | 除外理由 |
|------|---------|
| 面積 < 100pt² | ドットや微小な装飾 |
| 幅 < 3pt or 高さ < 3pt | 罫線・ボーダー線 |
| 塗りつぶし色のRGB全成分 > 0.95 | 白色背景（見えない） |
| 塗りつぶしなし（ストロークのみ） | 枠線のみ（背景ではない） |

### 6.3 PPTX上の表現

条件を通過した矩形は、`slide.shapes.add_shape(RECTANGLE)` で追加し、
`fill.solid()` + `fill.fore_color.rgb` で塗りつぶし色を設定する。
枠線は `line.fill.background()` で非表示にする。

---

## 7. 画像の処理

### 7.1 抽出フロー

```
page.get_images(full=True)         # ページ内の画像xref一覧を取得
  ↓
page.get_image_rects(xref)         # 各画像の表示位置（矩形）を取得
  ↓
doc.extract_image(xref)            # 画像バイナリデータを取得
  ↓
io.BytesIO(image_data)             # バイトストリームに変換
  ↓
slide.shapes.add_picture(stream)   # スライドに配置
```

### 7.2 対象

- ロゴ画像（中外製薬、ロシュ等）
- ラスタライズ済みのグラフ・チャート
- フロー図・アイコン

### 7.3 スキップ条件

- 幅 < 10pt or 高さ < 10pt（微小な装飾画像）

---

## 8. ファイル構成

```
pdf2pptx-prototype/
  ├── pdf2pptx.py          # メイン変換スクリプト
  ├── analyze_pdf.py       # PDF構造分析用（開発時のみ使用）
  └── 技術説明書.md         # 本ドキュメント
```

### 8.1 実行方法

```bash
# 基本実行
python3 pdf2pptx.py

# 引数指定
python3 pdf2pptx.py <入力PDF> <出力PPTX>
```

### 8.2 依存パッケージのインストール

```bash
pip3 install PyMuPDF python-pptx Pillow
```

---

## 9. 現在の制約と今後の改善方針

### 9.1 現在の制約

| 項目 | 現状 | 影響 |
|------|------|------|
| テーブル | テキストボックスの集合として配置 | PPTXのTableオブジェクトではないため、セル操作不可 |
| 罫線 | 未対応（フィルタで除外） | テーブルの罫線が表示されない |
| ベクターグラフ | 未対応 | PDF内で描画命令で構成されたグラフは変換されない |
| 縦書きテキスト | 未対応 | 横書きとして配置される |
| A4縦→16:9横 | 左右に余白が発生 | スライド幅の約60%にコンテンツが集中 |

### 9.2 改善方針

**Phase 1：精度向上**
- テーブルの自動検出と`Table`オブジェクトへの変換
- 罫線の再現（ストローク描画オブジェクトの処理）
- テキストボックスの重なり防止ロジック

**Phase 2：機能拡張**
- AIによるセクション自動分割・コンテンツの横展開（A4縦→複数の16:9横スライド）
- 企業テンプレートへの自動マッピング
- 複数PDF対応（バッチ処理）

**Phase 3：プロダクト化**
- Web UIでのアップロード→変換→ダウンロード
- REST API化
- 変換品質の自動評価レポート機能

---

## 10. 関数リファレンス

### `convert_pdf_to_pptx(pdf_path, output_path)`
メインのエントリーポイント。PDFを読み込み、全ページをスライドに変換して保存する。

### `calc_scaling(pdf_width, pdf_height) → (scale, offset_x, offset_y)`
PDF→スライドのスケール係数とセンタリングオフセットを計算する。

### `pdf_to_slide_coords(x, y, w, h, scale, offset_x, offset_y) → (sx, sy, sw, sh)`
PDF座標をスライド座標（EMU単位）に変換する。

### `merge_spans_into_lines(blocks) → lines_data`
PyMuPDFのBlock→Line→Span構造からLine単位のデータを抽出する。

### `group_lines_into_textboxes(lines_data) → textboxes`
近接するLineをグルーピングし、テキストボックス単位にまとめる。

### `add_background_shapes(slide, drawings, page_rect, scale, offset_x, offset_y) → count`
PDF内の描画矩形をフィルタリングし、スライド上に背景シェイプとして追加する。

### `extract_page_images_as_clip(page, slide, scale, offset_x, offset_y) → count`
ページ内の埋め込み画像を抽出し、スライド上に配置する。

### `add_textboxes(slide, textboxes, scale, offset_x, offset_y)`
グルーピング済みのテキストボックスをスライド上に追加する。書式（フォント・色・太字・斜体）を保持してマッピングする。

### `color_from_int(color_int) → RGBColor`
PyMuPDFのRGB整数値（0xRRGGBB）をpython-pptxのRGBColorに変換する。

### `color_from_tuple(color_tuple) → RGBColor`
PyMuPDFの浮動小数点RGB（0.0〜1.0）をRGBColorに変換する。
